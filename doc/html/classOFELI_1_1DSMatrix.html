<!-- XHTML 1.0 Strict -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<meta name="author" content="Rachid Touzani" />
<meta name="keywords" content=" css, dropdowns, dropdown menu, drop-down, menu, navigation, nav, horizontal, vertical left-to-right, vertical right-to-left, horizontal linear, horizontal upwards, cross browser, internet explorer, ie, firefox, safari, opera, browser, lwis" />
<meta name="description" content="Clean, standards-friendly, modular framework for dropdown menus" />
<link href="../css/dropdown.vertical.css" media="screen" rel="stylesheet" type="text/css" />
<link href="../css/default.ultimate.css" media="screen" rel="stylesheet" type="text/css" />
<head>
<!-- Title -->
<title>OFELI - Documentation</title>
<!-- Stylesheet -->
<link rel="stylesheet" type="text/css" href="../doxygen.css" />
<link rel="stylesheet" type="text/css" href="../tabs.css" />
</head>
<body>
<p align="center">
  <img src="../im/ofeli.gif" alt="OFELI's Logo" width="300" height="90">
</p>
<p align="center"><font color="#203F5B" size="4" face="verdana,Helvetica">
<b>An Object Oriented Finite Element Library</b></font></p>
<!-- Complete Page-->
<div id="main">
<div id="mainmenu">
 <div class="text">
<!-- Menu -->
 <div class="tabs">
  <ul class="tablist">
   <li><a href="../index.html"><span>Home</span></a>
    <li><a href="../overview.html"><span>Overview</span></a>
    <li><a href="../extlib.html"><span>External Libraries</span></a>
    <li><a href="../citing.html"><span>Citing OFELI</span></a>
    <li><a href="../fformats.html"><span>File Formats</span></a>
    <li><a href="../demos.html"><span>Demo Codes</span></a>
  </ul>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classOFELI_1_1DSMatrix.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classOFELI_1_1DSMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DSMatrix&lt; T_ &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__OFELI.html">OFELI</a><a class="el" href="group__OFELI.html">OFELI</a> &raquo;  &#124; <a class="el" href="group__VectMat.html">Vector and Matrix</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>To handle symmetric dense matrices.  
 <a href="classOFELI_1_1DSMatrix.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for DSMatrix&lt; T_ &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classOFELI_1_1DSMatrix.png" usemap="#DSMatrix_3C_20T_5F_20_3E_map" alt=""/>
  <map id="DSMatrix_3C_20T_5F_20_3E_map" name="DSMatrix&lt; T_ &gt;_map">
<area href="classOFELI_1_1Matrix.html" title="Virtual class to handle matrices for all storage formats. " alt="Matrix&lt; T_ &gt;" shape="rect" coords="0,0,102,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a08ae6140469ed278cac12a8c19d2484a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08ae6140469ed278cac12a8c19d2484a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a08ae6140469ed278cac12a8c19d2484a">DSMatrix</a> ()</td></tr>
<tr class="memdesc:a08ae6140469ed278cac12a8c19d2484a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a08ae6140469ed278cac12a8c19d2484a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba078f0db8e9655216b785022c4b1ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a7ba078f0db8e9655216b785022c4b1ce">DSMatrix</a> (size_t dim)</td></tr>
<tr class="memdesc:a7ba078f0db8e9655216b785022c4b1ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that for a symmetric matrix with given number of râ€¡qows.  <a href="#a7ba078f0db8e9655216b785022c4b1ce">More...</a><br /></td></tr>
<tr class="separator:a7ba078f0db8e9655216b785022c4b1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006340889cb6a1ae9e2c8f475a6d9789"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a006340889cb6a1ae9e2c8f475a6d9789">DSMatrix</a> (const <a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:a006340889cb6a1ae9e2c8f475a6d9789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor.  <a href="#a006340889cb6a1ae9e2c8f475a6d9789">More...</a><br /></td></tr>
<tr class="separator:a006340889cb6a1ae9e2c8f475a6d9789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1799398ea24c5d41cc3cdb1e2ecbfa4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#af1799398ea24c5d41cc3cdb1e2ecbfa4">DSMatrix</a> (<a class="el" href="classOFELI_1_1Mesh.html">Mesh</a> &amp;mesh, size_t dof=0, int is_diagonal=false)</td></tr>
<tr class="memdesc:af1799398ea24c5d41cc3cdb1e2ecbfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using mesh to initialize matrix.  <a href="#af1799398ea24c5d41cc3cdb1e2ecbfa4">More...</a><br /></td></tr>
<tr class="separator:af1799398ea24c5d41cc3cdb1e2ecbfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6975daaae7752bf91aaa02626da792"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf6975daaae7752bf91aaa02626da792"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#acf6975daaae7752bf91aaa02626da792">~DSMatrix</a> ()</td></tr>
<tr class="memdesc:acf6975daaae7752bf91aaa02626da792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:acf6975daaae7752bf91aaa02626da792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e475404ab75bd6cfe18a2aeb76a7de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4e475404ab75bd6cfe18a2aeb76a7de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#ac4e475404ab75bd6cfe18a2aeb76a7de">setDiag</a> ()</td></tr>
<tr class="memdesc:ac4e475404ab75bd6cfe18a2aeb76a7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store diagonal entries in a separate internal vector. <br /></td></tr>
<tr class="separator:ac4e475404ab75bd6cfe18a2aeb76a7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29a2810da48f84a0cc274a83c21486c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#ac29a2810da48f84a0cc274a83c21486c">setSize</a> (size_t dim)</td></tr>
<tr class="memdesc:ac29a2810da48f84a0cc274a83c21486c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set size (number of rows) of matrix.  <a href="#ac29a2810da48f84a0cc274a83c21486c">More...</a><br /></td></tr>
<tr class="separator:ac29a2810da48f84a0cc274a83c21486c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cf373a94a5fedbca306e016bc489c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a61cf373a94a5fedbca306e016bc489c9">set</a> (size_t i, size_t j, const T_ &amp;val)</td></tr>
<tr class="memdesc:a61cf373a94a5fedbca306e016bc489c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign constant to entry <code>(i,j)</code> of the matrix.  <a href="#a61cf373a94a5fedbca306e016bc489c9">More...</a><br /></td></tr>
<tr class="separator:a61cf373a94a5fedbca306e016bc489c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6afdfede402d3a49733ee7fc461625"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a1c6afdfede402d3a49733ee7fc461625">getColumn</a> (size_t j, <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;v) const </td></tr>
<tr class="memdesc:a1c6afdfede402d3a49733ee7fc461625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <code>j</code>-th column vector.  <a href="#a1c6afdfede402d3a49733ee7fc461625">More...</a><br /></td></tr>
<tr class="separator:a1c6afdfede402d3a49733ee7fc461625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b22a9bdb6e7816adda67eb2b3fcadd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a41b22a9bdb6e7816adda67eb2b3fcadd">getColumn</a> (size_t j) const </td></tr>
<tr class="memdesc:a41b22a9bdb6e7816adda67eb2b3fcadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <code>j</code>-th column vector.  <a href="#a41b22a9bdb6e7816adda67eb2b3fcadd">More...</a><br /></td></tr>
<tr class="separator:a41b22a9bdb6e7816adda67eb2b3fcadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97237e5c52ffcc6fae8abd88c795b1f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a97237e5c52ffcc6fae8abd88c795b1f4">getRow</a> (size_t i, <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;v) const </td></tr>
<tr class="memdesc:a97237e5c52ffcc6fae8abd88c795b1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <code>i</code>-th row vector.  <a href="#a97237e5c52ffcc6fae8abd88c795b1f4">More...</a><br /></td></tr>
<tr class="separator:a97237e5c52ffcc6fae8abd88c795b1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4442e9e5d2d998bdeed7382f72416c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#aca4442e9e5d2d998bdeed7382f72416c">getRow</a> (size_t i) const </td></tr>
<tr class="memdesc:aca4442e9e5d2d998bdeed7382f72416c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <code>i</code>-th row vector.  <a href="#aca4442e9e5d2d998bdeed7382f72416c">More...</a><br /></td></tr>
<tr class="separator:aca4442e9e5d2d998bdeed7382f72416c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0e68c1876d30d52009f2da7b70bac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#aef0e68c1876d30d52009f2da7b70bac4">setRow</a> (size_t i, const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;v)</td></tr>
<tr class="memdesc:aef0e68c1876d30d52009f2da7b70bac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a given vector to a prescribed row in the matrix.  <a href="#aef0e68c1876d30d52009f2da7b70bac4">More...</a><br /></td></tr>
<tr class="separator:aef0e68c1876d30d52009f2da7b70bac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6676c0ae519b1521591486fdfd798c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#afa6676c0ae519b1521591486fdfd798c">setColumn</a> (size_t j, const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;v)</td></tr>
<tr class="memdesc:afa6676c0ae519b1521591486fdfd798c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a given vector to a prescribed column in the matrix.  <a href="#afa6676c0ae519b1521591486fdfd798c">More...</a><br /></td></tr>
<tr class="separator:afa6676c0ae519b1521591486fdfd798c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada43e388310892d120dc1e2e2f9841ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#ada43e388310892d120dc1e2e2f9841ea">setDiag</a> (const T_ &amp;a)</td></tr>
<tr class="memdesc:ada43e388310892d120dc1e2e2f9841ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set matrix as diagonal and assign its diagonal entries as a constant.  <a href="#ada43e388310892d120dc1e2e2f9841ea">More...</a><br /></td></tr>
<tr class="separator:ada43e388310892d120dc1e2e2f9841ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98bbfc7e1ef49f12a4eae45c0d0bf17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#aa98bbfc7e1ef49f12a4eae45c0d0bf17">setDiag</a> (const vector&lt; T_ &gt; &amp;d)</td></tr>
<tr class="memdesc:aa98bbfc7e1ef49f12a4eae45c0d0bf17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set matrix as diagonal and assign its diagonal entries.  <a href="#aa98bbfc7e1ef49f12a4eae45c0d0bf17">More...</a><br /></td></tr>
<tr class="separator:aa98bbfc7e1ef49f12a4eae45c0d0bf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17592a65d5fb95d42c07f724dabad759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a17592a65d5fb95d42c07f724dabad759">add</a> (size_t i, size_t j, const T_ &amp;val)</td></tr>
<tr class="memdesc:a17592a65d5fb95d42c07f724dabad759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add constant to an entry ofthe matrix.  <a href="#a17592a65d5fb95d42c07f724dabad759">More...</a><br /></td></tr>
<tr class="separator:a17592a65d5fb95d42c07f724dabad759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d11677b77c61b1c2530c0295d9a966"><td class="memItemLeft" align="right" valign="top">T_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#af4d11677b77c61b1c2530c0295d9a966">operator()</a> (size_t i, size_t j) const </td></tr>
<tr class="memdesc:af4d11677b77c61b1c2530c0295d9a966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator <code>()</code> (Constant version).  <a href="#af4d11677b77c61b1c2530c0295d9a966">More...</a><br /></td></tr>
<tr class="separator:af4d11677b77c61b1c2530c0295d9a966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906d09665a54a68d6333925dc83c57c8"><td class="memItemLeft" align="right" valign="top">T_ &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a906d09665a54a68d6333925dc83c57c8">operator()</a> (size_t i, size_t j)</td></tr>
<tr class="memdesc:a906d09665a54a68d6333925dc83c57c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator <code>()</code> (Non constant version).  <a href="#a906d09665a54a68d6333925dc83c57c8">More...</a><br /></td></tr>
<tr class="separator:a906d09665a54a68d6333925dc83c57c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bbe0943262417e0ca83a7704ab8d8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5bbe0943262417e0ca83a7704ab8d8d"></a>
<a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a>&lt; T_ &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#ae5bbe0943262417e0ca83a7704ab8d8d">operator=</a> (const <a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:ae5bbe0943262417e0ca83a7704ab8d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator <code>=</code> Copy matrix <code>m</code> to current matrix instance. <br /></td></tr>
<tr class="separator:ae5bbe0943262417e0ca83a7704ab8d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c27c314e6929a0d131c04b75367f15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5c27c314e6929a0d131c04b75367f15"></a>
<a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a>&lt; T_ &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#ac5c27c314e6929a0d131c04b75367f15">operator=</a> (const T_ &amp;x)</td></tr>
<tr class="memdesc:ac5c27c314e6929a0d131c04b75367f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator = Assign matrix to identity times <code>x</code>. <br /></td></tr>
<tr class="separator:ac5c27c314e6929a0d131c04b75367f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa218e14d008e826772c114538f8fb525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#aa218e14d008e826772c114538f8fb525">operator+=</a> (const T_ &amp;x)</td></tr>
<tr class="memdesc:aa218e14d008e826772c114538f8fb525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator +=.  <a href="#aa218e14d008e826772c114538f8fb525">More...</a><br /></td></tr>
<tr class="separator:aa218e14d008e826772c114538f8fb525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfe4c4c7613e852d114ec417f714bc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#abdfe4c4c7613e852d114ec417f714bc8">operator-=</a> (const T_ &amp;x)</td></tr>
<tr class="memdesc:abdfe4c4c7613e852d114ec417f714bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator -=.  <a href="#abdfe4c4c7613e852d114ec417f714bc8">More...</a><br /></td></tr>
<tr class="separator:abdfe4c4c7613e852d114ec417f714bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad177e53c00ddc5579499a4ae8a67c1ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#ad177e53c00ddc5579499a4ae8a67c1ac">setLDLt</a> ()</td></tr>
<tr class="memdesc:ad177e53c00ddc5579499a4ae8a67c1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize matrix (<code>LDL<sup>T</sup></code>)  <a href="#ad177e53c00ddc5579499a4ae8a67c1ac">More...</a><br /></td></tr>
<tr class="separator:ad177e53c00ddc5579499a4ae8a67c1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891baacc01ccea53b33d0da6fd57d653"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a891baacc01ccea53b33d0da6fd57d653"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a891baacc01ccea53b33d0da6fd57d653">MultAdd</a> (const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;x, <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;y) const </td></tr>
<tr class="memdesc:a891baacc01ccea53b33d0da6fd57d653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply matrix by vector <code>a*x</code> and add result to <code>y</code>. <br /></td></tr>
<tr class="separator:a891baacc01ccea53b33d0da6fd57d653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182aa2a623c3a9e200cc74350c173c9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a182aa2a623c3a9e200cc74350c173c9b">MultAdd</a> (T_ a, const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;x, <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;y) const </td></tr>
<tr class="memdesc:a182aa2a623c3a9e200cc74350c173c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply matrix by vector <code>a*x</code> and add to <code>y</code>.  <a href="#a182aa2a623c3a9e200cc74350c173c9b">More...</a><br /></td></tr>
<tr class="separator:a182aa2a623c3a9e200cc74350c173c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a7c8856e21eb23fa804f0d2f6e893b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3a7c8856e21eb23fa804f0d2f6e893b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#af3a7c8856e21eb23fa804f0d2f6e893b">Mult</a> (const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;x, <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;y) const </td></tr>
<tr class="memdesc:af3a7c8856e21eb23fa804f0d2f6e893b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply matrix by vector <code>x</code> and save result in <code>y</code>. <br /></td></tr>
<tr class="separator:af3a7c8856e21eb23fa804f0d2f6e893b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d263a3302f9ee2a9a6401080ce9b90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a46d263a3302f9ee2a9a6401080ce9b90">TMult</a> (const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;x, <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;y) const </td></tr>
<tr class="memdesc:a46d263a3302f9ee2a9a6401080ce9b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply transpose of matrix by vector <code>x</code> and add result in <code>y</code>.  <a href="#a46d263a3302f9ee2a9a6401080ce9b90">More...</a><br /></td></tr>
<tr class="separator:a46d263a3302f9ee2a9a6401080ce9b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71951ea22c5e9d656c2ff6bcabd0850b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a71951ea22c5e9d656c2ff6bcabd0850b">Axpy</a> (T_ a, const <a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:a71951ea22c5e9d656c2ff6bcabd0850b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to matrix the product of a matrix by a scalar.  <a href="#a71951ea22c5e9d656c2ff6bcabd0850b">More...</a><br /></td></tr>
<tr class="separator:a71951ea22c5e9d656c2ff6bcabd0850b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ecd57722b088d883cdb26ac2887270"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#ac7ecd57722b088d883cdb26ac2887270">Axpy</a> (T_ a, const <a class="el" href="classOFELI_1_1Matrix.html">Matrix</a>&lt; T_ &gt; *m)</td></tr>
<tr class="memdesc:ac7ecd57722b088d883cdb26ac2887270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to matrix the product of a matrix by a scalar.  <a href="#ac7ecd57722b088d883cdb26ac2887270">More...</a><br /></td></tr>
<tr class="separator:ac7ecd57722b088d883cdb26ac2887270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85abe8e904adb7fd09103d7b3e8e362d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a85abe8e904adb7fd09103d7b3e8e362d">solve</a> (<a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="group__OFELI.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, bool fact=true)</td></tr>
<tr class="memdesc:a85abe8e904adb7fd09103d7b3e8e362d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear system.  <a href="#a85abe8e904adb7fd09103d7b3e8e362d">More...</a><br /></td></tr>
<tr class="separator:a85abe8e904adb7fd09103d7b3e8e362d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c662f32ce66be2efa47871358fcf10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a27c662f32ce66be2efa47871358fcf10">solve</a> (const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="group__OFELI.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;x, bool fact=true)</td></tr>
<tr class="memdesc:a27c662f32ce66be2efa47871358fcf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear system.  <a href="#a27c662f32ce66be2efa47871358fcf10">More...</a><br /></td></tr>
<tr class="separator:a27c662f32ce66be2efa47871358fcf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094470ce0ea2e96ada8f1c888230a520"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a094470ce0ea2e96ada8f1c888230a520"></a>
T_ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a094470ce0ea2e96ada8f1c888230a520">getArray</a> () const </td></tr>
<tr class="memdesc:a094470ce0ea2e96ada8f1c888230a520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return matrix as C-Array. <a class="el" href="classOFELI_1_1Matrix.html" title="Virtual class to handle matrices for all storage formats. ">Matrix</a> is stored row by row. Only lower triangle is stored. <br /></td></tr>
<tr class="separator:a094470ce0ea2e96ada8f1c888230a520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7b1d2724593a6ec1212247d7964b8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a7b1d2724593a6ec1212247d7964b8e"></a>
T_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1DSMatrix.html#a7a7b1d2724593a6ec1212247d7964b8e">get</a> (size_t i, size_t j) const </td></tr>
<tr class="memdesc:a7a7b1d2724593a6ec1212247d7964b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return entry <code>(i,j)</code> of matrix. <br /></td></tr>
<tr class="separator:a7a7b1d2724593a6ec1212247d7964b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0e029102ad38f4b814c6523aedb53d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a7b0e029102ad38f4b814c6523aedb53d">reset</a> ()</td></tr>
<tr class="memdesc:a7b0e029102ad38f4b814c6523aedb53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set matrix to 0 and reset factorization parameter.  <a href="#a7b0e029102ad38f4b814c6523aedb53d">More...</a><br /></td></tr>
<tr class="separator:a7b0e029102ad38f4b814c6523aedb53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64de7025d9f5712288b3093ca5408b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac64de7025d9f5712288b3093ca5408b1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#ac64de7025d9f5712288b3093ca5408b1">getNbRows</a> () const </td></tr>
<tr class="memdesc:ac64de7025d9f5712288b3093ca5408b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of rows. <br /></td></tr>
<tr class="separator:ac64de7025d9f5712288b3093ca5408b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879356293a4c2120a7f87bf231ce341c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a879356293a4c2120a7f87bf231ce341c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a879356293a4c2120a7f87bf231ce341c">getNbColumns</a> () const </td></tr>
<tr class="memdesc:a879356293a4c2120a7f87bf231ce341c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of columns. <br /></td></tr>
<tr class="separator:a879356293a4c2120a7f87bf231ce341c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72077468b17118c44394d286f7737bd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72077468b17118c44394d286f7737bd4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a72077468b17118c44394d286f7737bd4">setPenal</a> (<a class="el" href="group__Util.html#gaccfeb6b1e8cf41731fde610549bee67c">real_t</a> p)</td></tr>
<tr class="memdesc:a72077468b17118c44394d286f7737bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Penalty Parameter (For boundary condition prescription). <br /></td></tr>
<tr class="separator:a72077468b17118c44394d286f7737bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282ce97ddc94a4ad0030c047b35332ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a282ce97ddc94a4ad0030c047b35332ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a282ce97ddc94a4ad0030c047b35332ca">setDiagonal</a> ()</td></tr>
<tr class="memdesc:a282ce97ddc94a4ad0030c047b35332ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the matrix as diagonal. <br /></td></tr>
<tr class="separator:a282ce97ddc94a4ad0030c047b35332ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196d9e08fa42335a41f8e67082215065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a196d9e08fa42335a41f8e67082215065">setDiagonal</a> (<a class="el" href="classOFELI_1_1Mesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:a196d9e08fa42335a41f8e67082215065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize matrix storage in the case where only diagonal terms are stored.  <a href="#a196d9e08fa42335a41f8e67082215065">More...</a><br /></td></tr>
<tr class="separator:a196d9e08fa42335a41f8e67082215065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fae0c47b38f34c0c764b2b6109f9d5"><td class="memItemLeft" align="right" valign="top">T_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a06fae0c47b38f34c0c764b2b6109f9d5">getDiag</a> (size_t k) const </td></tr>
<tr class="memdesc:a06fae0c47b38f34c0c764b2b6109f9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>k</code>-th diagonal entry of matrix.  <a href="#a06fae0c47b38f34c0c764b2b6109f9d5">More...</a><br /></td></tr>
<tr class="separator:a06fae0c47b38f34c0c764b2b6109f9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac782da1f912bceb5d8ad00c8dc892ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac782da1f912bceb5d8ad00c8dc892ac"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#aac782da1f912bceb5d8ad00c8dc892ac">size</a> () const </td></tr>
<tr class="memdesc:aac782da1f912bceb5d8ad00c8dc892ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return matrix dimension (Number of rows and columns). <br /></td></tr>
<tr class="separator:aac782da1f912bceb5d8ad00c8dc892ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae048282c7011eedc2e0492f6421ea73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae048282c7011eedc2e0492f6421ea73"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#aae048282c7011eedc2e0492f6421ea73">clear</a> ()</td></tr>
<tr class="memdesc:aae048282c7011eedc2e0492f6421ea73"><td class="mdescLeft">&#160;</td><td class="mdescRight">brief Set all matrix entries to zero <br /></td></tr>
<tr class="separator:aae048282c7011eedc2e0492f6421ea73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8f063011ae37198a6c96ad00da6188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#aae8f063011ae37198a6c96ad00da6188">Assembly</a> (const <a class="el" href="classOFELI_1_1Element.html">Element</a> &amp;el, T_ *a)</td></tr>
<tr class="memdesc:aae8f063011ae37198a6c96ad00da6188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembly of element matrix into global matrix.  <a href="#aae8f063011ae37198a6c96ad00da6188">More...</a><br /></td></tr>
<tr class="separator:aae8f063011ae37198a6c96ad00da6188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377c96d9edc5455d8b81d7f2e75a7437"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a377c96d9edc5455d8b81d7f2e75a7437">Assembly</a> (const <a class="el" href="classOFELI_1_1Side.html">Side</a> &amp;sd, T_ *a)</td></tr>
<tr class="memdesc:a377c96d9edc5455d8b81d7f2e75a7437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembly of side matrix into global matrix.  <a href="#a377c96d9edc5455d8b81d7f2e75a7437">More...</a><br /></td></tr>
<tr class="separator:a377c96d9edc5455d8b81d7f2e75a7437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1775cd968f5d809fed17f111c852a8f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a1775cd968f5d809fed17f111c852a8f4">Prescribe</a> (<a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="group__OFELI.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;u, int flag=0)</td></tr>
<tr class="memdesc:a1775cd968f5d809fed17f111c852a8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose by a penalty method an essential boundary condition, using the <a class="el" href="classOFELI_1_1Mesh.html" title="To store and manipulate finite element meshes. ">Mesh</a> instance provided by the constructor.  <a href="#a1775cd968f5d809fed17f111c852a8f4">More...</a><br /></td></tr>
<tr class="separator:a1775cd968f5d809fed17f111c852a8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9143a391d39e2b1c8fc092d18a2c01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a5e9143a391d39e2b1c8fc092d18a2c01">Prescribe</a> (int dof, int code, <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="group__OFELI.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;u, int flag=0)</td></tr>
<tr class="memdesc:a5e9143a391d39e2b1c8fc092d18a2c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose by a penalty method an essential boundary condition to a given degree of freedom for a given code.  <a href="#a5e9143a391d39e2b1c8fc092d18a2c01">More...</a><br /></td></tr>
<tr class="separator:a5e9143a391d39e2b1c8fc092d18a2c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d58b8c69697615bb891ad8d89192e11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a3d58b8c69697615bb891ad8d89192e11">Prescribe</a> (<a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="group__OFELI.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, int flag=0)</td></tr>
<tr class="memdesc:a3d58b8c69697615bb891ad8d89192e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose by a penalty method a homegeneous (=0) essential boundary condition.  <a href="#a3d58b8c69697615bb891ad8d89192e11">More...</a><br /></td></tr>
<tr class="separator:a3d58b8c69697615bb891ad8d89192e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a278a1ed1bb0a7a6df613e63816c8cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a0a278a1ed1bb0a7a6df613e63816c8cf">Prescribe</a> (size_t dof, <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="group__OFELI.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;u, int flag=0)</td></tr>
<tr class="memdesc:a0a278a1ed1bb0a7a6df613e63816c8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose by a penalty method an essential boundary condition when only one DOF is treated.  <a href="#a0a278a1ed1bb0a7a6df613e63816c8cf">More...</a><br /></td></tr>
<tr class="separator:a0a278a1ed1bb0a7a6df613e63816c8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4668862b3d13a8ac8ffec768b7e38631"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a4668862b3d13a8ac8ffec768b7e38631">PrescribeSide</a> ()</td></tr>
<tr class="memdesc:a4668862b3d13a8ac8ffec768b7e38631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose by a penalty method an essential boundary condition when DOFs are supported by sides.  <a href="#a4668862b3d13a8ac8ffec768b7e38631">More...</a><br /></td></tr>
<tr class="separator:a4668862b3d13a8ac8ffec768b7e38631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f6b1105cb4953c3f56b5c51ed4b046"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9f6b1105cb4953c3f56b5c51ed4b046"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#ab9f6b1105cb4953c3f56b5c51ed4b046">Factor</a> ()=0</td></tr>
<tr class="memdesc:ab9f6b1105cb4953c3f56b5c51ed4b046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize matrix. Available only if the storage class enables it. <br /></td></tr>
<tr class="separator:ab9f6b1105cb4953c3f56b5c51ed4b046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70ebb919bf4d6e5e646c1c113392a79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#af70ebb919bf4d6e5e646c1c113392a79">FactorAndSolve</a> (<a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="group__OFELI.html#gaf5cd2eaaceda19772fd904539819158c">b</a>)</td></tr>
<tr class="memdesc:af70ebb919bf4d6e5e646c1c113392a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize matrix and solve the linear system.  <a href="#af70ebb919bf4d6e5e646c1c113392a79">More...</a><br /></td></tr>
<tr class="separator:af70ebb919bf4d6e5e646c1c113392a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20265f18b86fdc36c0c694d34bb01db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#ad20265f18b86fdc36c0c694d34bb01db">FactorAndSolve</a> (const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="group__OFELI.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;x)</td></tr>
<tr class="memdesc:ad20265f18b86fdc36c0c694d34bb01db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize matrix and solve the linear system.  <a href="#ad20265f18b86fdc36c0c694d34bb01db">More...</a><br /></td></tr>
<tr class="separator:ad20265f18b86fdc36c0c694d34bb01db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d4c55c333f8db2cc206b90b1e53041"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68d4c55c333f8db2cc206b90b1e53041"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a68d4c55c333f8db2cc206b90b1e53041">getLength</a> () const </td></tr>
<tr class="memdesc:a68d4c55c333f8db2cc206b90b1e53041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of stored terms in matrix. <br /></td></tr>
<tr class="separator:a68d4c55c333f8db2cc206b90b1e53041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01047a7f68670914394281ab80f89947"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01047a7f68670914394281ab80f89947"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a01047a7f68670914394281ab80f89947">isDiagonal</a> () const </td></tr>
<tr class="memdesc:a01047a7f68670914394281ab80f89947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Say if matrix is diagonal or not. <br /></td></tr>
<tr class="separator:a01047a7f68670914394281ab80f89947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db6c5f267140ce71d02b845638d6229"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a1db6c5f267140ce71d02b845638d6229">isFactorized</a> () const </td></tr>
<tr class="memdesc:a1db6c5f267140ce71d02b845638d6229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Say if matrix is factorized or not.  <a href="#a1db6c5f267140ce71d02b845638d6229">More...</a><br /></td></tr>
<tr class="separator:a1db6c5f267140ce71d02b845638d6229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f6cc2fefdae6c493609bb253d571b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4f6cc2fefdae6c493609bb253d571b7"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#af4f6cc2fefdae6c493609bb253d571b7">getColInd</a> (size_t i) const </td></tr>
<tr class="memdesc:af4f6cc2fefdae6c493609bb253d571b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Column index for column <code>i</code> (See the description for class <a class="el" href="classOFELI_1_1SpMatrix.html" title="To handle matrices in sparse storage format. ">SpMatrix</a>). <br /></td></tr>
<tr class="separator:af4f6cc2fefdae6c493609bb253d571b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10438b6ef525d89a3fdfb549b03b4488"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10438b6ef525d89a3fdfb549b03b4488"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a10438b6ef525d89a3fdfb549b03b4488">getRowPtr</a> (size_t i) const </td></tr>
<tr class="memdesc:a10438b6ef525d89a3fdfb549b03b4488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Row pointer for row <code>i</code> (See the description for class <a class="el" href="classOFELI_1_1SpMatrix.html" title="To handle matrices in sparse storage format. ">SpMatrix</a>). <br /></td></tr>
<tr class="separator:a10438b6ef525d89a3fdfb549b03b4488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddc9619401846e377b99d5f35e21580"><td class="memItemLeft" align="right" valign="top">T_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a5ddc9619401846e377b99d5f35e21580">operator()</a> (size_t i) const </td></tr>
<tr class="memdesc:a5ddc9619401846e377b99d5f35e21580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator () with one argument (Constant version).  <a href="#a5ddc9619401846e377b99d5f35e21580">More...</a><br /></td></tr>
<tr class="separator:a5ddc9619401846e377b99d5f35e21580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fb7738730bfcc21b07ede2b6137fc9"><td class="memItemLeft" align="right" valign="top">T_ &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#ad7fb7738730bfcc21b07ede2b6137fc9">operator()</a> (size_t i)</td></tr>
<tr class="memdesc:ad7fb7738730bfcc21b07ede2b6137fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator () with one argument (Non Constant version).  <a href="#ad7fb7738730bfcc21b07ede2b6137fc9">More...</a><br /></td></tr>
<tr class="separator:ad7fb7738730bfcc21b07ede2b6137fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760177d294663b1dd8941afd331b0fbb"><td class="memItemLeft" align="right" valign="top">T_ &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a760177d294663b1dd8941afd331b0fbb">operator[]</a> (size_t k)</td></tr>
<tr class="memdesc:a760177d294663b1dd8941afd331b0fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator [] (Non constant version).  <a href="#a760177d294663b1dd8941afd331b0fbb">More...</a><br /></td></tr>
<tr class="separator:a760177d294663b1dd8941afd331b0fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9fc831c3cfa8fe5b57e99da5ac1e52"><td class="memItemLeft" align="right" valign="top">T_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a0c9fc831c3cfa8fe5b57e99da5ac1e52">operator[]</a> (size_t k) const </td></tr>
<tr class="memdesc:a0c9fc831c3cfa8fe5b57e99da5ac1e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator [] (Constant version).  <a href="#a0c9fc831c3cfa8fe5b57e99da5ac1e52">More...</a><br /></td></tr>
<tr class="separator:a0c9fc831c3cfa8fe5b57e99da5ac1e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cbfbe86d6789ebc8b34b261402fb9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFELI_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#aa3cbfbe86d6789ebc8b34b261402fb9a">operator+=</a> (const <a class="el" href="classOFELI_1_1Matrix.html">Matrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:aa3cbfbe86d6789ebc8b34b261402fb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator +=.  <a href="#aa3cbfbe86d6789ebc8b34b261402fb9a">More...</a><br /></td></tr>
<tr class="separator:aa3cbfbe86d6789ebc8b34b261402fb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f89bc074972e8d49e6459ea384d672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFELI_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a82f89bc074972e8d49e6459ea384d672">operator-=</a> (const <a class="el" href="classOFELI_1_1Matrix.html">Matrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:a82f89bc074972e8d49e6459ea384d672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator -=.  <a href="#a82f89bc074972e8d49e6459ea384d672">More...</a><br /></td></tr>
<tr class="separator:a82f89bc074972e8d49e6459ea384d672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1370eca69f9880d5456fb9f4e1da44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOFELI_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOFELI_1_1Matrix.html#a7c1370eca69f9880d5456fb9f4e1da44">operator*=</a> (const T_ &amp;x)</td></tr>
<tr class="memdesc:a7c1370eca69f9880d5456fb9f4e1da44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator *=.  <a href="#a7c1370eca69f9880d5456fb9f4e1da44">More...</a><br /></td></tr>
<tr class="separator:a7c1370eca69f9880d5456fb9f4e1da44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T_&gt;<br />
class OFELI::DSMatrix&lt; T_ &gt;</h3>

<p>To handle symmetric dense matrices. </p>
<p>This class enables storing and manipulating symmetric dense matrices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_</td><td>Data type (double, float, complex&lt;double&gt;, ...)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Rachid Touzani </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>GNU Lesser Public License </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7ba078f0db8e9655216b785022c4b1ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that for a symmetric matrix with given number of râ€¡qows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Number of rows </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a006340889cb6a1ae9e2c8f475a6d9789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td><a class="el" href="classOFELI_1_1DSMatrix.html" title="To handle symmetric dense matrices. ">DSMatrix</a> instance to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1799398ea24c5d41cc3cdb1e2ecbfa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor using mesh to initialize matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="classOFELI_1_1Mesh.html" title="To store and manipulate finite element meshes. ">Mesh</a> instance for which matrix graph is determined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>Option parameter, with default value <code>0</code>.<br />
<code>dof=1</code> means that only one degree of freedom for each node (or element or side) is taken to determine matrix structure. The value <code>dof=0</code> means that matrix structure is determined using all DOFs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_diagonal</td><td>Boolean argument to say is the matrix is actually a diagonal matrix or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac29a2810da48f84a0cc274a83c21486c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set size (number of rows) of matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Number of rows and columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61cf373a94a5fedbca306e016bc489c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_ &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign constant to entry <code>(i,j)</code> of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>column index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to assign to <code>a(i,j)</code> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classOFELI_1_1Matrix.html#ac0cea700fd87a3493ee917937ca21796">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1c6afdfede402d3a49733ee7fc461625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getColumn </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <code>j</code>-th column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Index of column to extract </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Reference to <a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance where the column is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Vector v does not need to be sized before. It is resized in the function </dd></dl>

</div>
</div>
<a class="anchor" id="a41b22a9bdb6e7816adda67eb2b3fcadd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt;T_&gt; getColumn </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <code>j</code>-th column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Index of column to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance where the column is stored </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Vector v does not need to be sized before. It is resized in the function </dd></dl>

</div>
</div>
<a class="anchor" id="a97237e5c52ffcc6fae8abd88c795b1f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <code>i</code>-th row vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of row to extract </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Reference to <a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance where the row is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Vector v does not need to be sized before. It is resized in the function </dd></dl>

</div>
</div>
<a class="anchor" id="aca4442e9e5d2d998bdeed7382f72416c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt;T_&gt; getRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <code>i</code>-th row vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of row to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance where the row is stored </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Vector v does not need to be sized before. It is resized in the function </dd></dl>

</div>
</div>
<a class="anchor" id="aef0e68c1876d30d52009f2da7b70bac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a given vector to a prescribed row in the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index to be assigned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa6676c0ae519b1521591486fdfd798c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setColumn </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a given vector to a prescribed column in the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>column index to be assigned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada43e388310892d120dc1e2e2f9841ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDiag </td>
          <td>(</td>
          <td class="paramtype">const T_ &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set matrix as diagonal and assign its diagonal entries as a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Value to assign to all diagonal entries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa98bbfc7e1ef49f12a4eae45c0d0bf17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDiag </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set matrix as diagonal and assign its diagonal entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>Vector entries to assign to matrix diagonal entries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17592a65d5fb95d42c07f724dabad759"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_ &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add constant to an entry ofthe matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>column index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to add to <code>a(i,j)</code> </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classOFELI_1_1Matrix.html#a8afb24c3d7982f994ea2c4a50444ed86">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af4d11677b77c61b1c2530c0295d9a966"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_ operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator <code>()</code> (Constant version). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Row index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Column index </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classOFELI_1_1Matrix.html#a5414ae5692942759e032a895a05f3903">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a906d09665a54a68d6333925dc83c57c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_&amp; operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator <code>()</code> (Non constant version). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Row index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Column index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>To modify a value of an entry of the matrix it is safer not to modify both lower and upper triangles. Otherwise, wrong values will be assigned. If not sure, use the member functions set or add. </dd></dl>

<p>Implements <a class="el" href="classOFELI_1_1Matrix.html#a98a5eea24da5bcb89516b2bd80a652d2">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa218e14d008e826772c114538f8fb525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const T_ &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator +=. </p>
<p>Add constant value <code>x</code> to all matrix entries. </p>

</div>
</div>
<a class="anchor" id="abdfe4c4c7613e852d114ec417f714bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a>&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const T_ &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator -=. </p>
<p>Subtract constant value <code>x</code> from to all matrix entries. </p>

</div>
</div>
<a class="anchor" id="ad177e53c00ddc5579499a4ae8a67c1ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setLDLt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factorize matrix (<code>LDL<sup>T</sup></code>) </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<code>0</code>, if factorization was normally performed, </li>
<li>
<code>n</code>, if the <code>n</code>-th pivot is null. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a182aa2a623c3a9e200cc74350c173c9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultAdd </td>
          <td>(</td>
          <td class="paramtype">T_&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply matrix by vector <code>a*x</code> and add to <code>y</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Constant to multiply by matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector to multiply by matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>Vector to add to the result. <code>y</code> contains on output the result. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classOFELI_1_1Matrix.html#a4de5f97fbbb24b50dc41e838620db33f">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a46d263a3302f9ee2a9a6401080ce9b90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TMult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply transpose of matrix by vector <code>x</code> and add result in <code>y</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector to add to <code>y</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>on input, vector to add to. On output, result. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classOFELI_1_1Matrix.html#a1b597cd493e07b35bdd57e351ad71580">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a71951ea22c5e9d656c2ff6bcabd0850b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Axpy </td>
          <td>(</td>
          <td class="paramtype">T_&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1DSMatrix.html">DSMatrix</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to matrix the product of a matrix by a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Scalar to premultiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Matrix by which <code>a</code> is multiplied. The result is added to current instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7ecd57722b088d883cdb26ac2887270"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Axpy </td>
          <td>(</td>
          <td class="paramtype">T_&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Matrix.html">Matrix</a>&lt; T_ &gt; *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add to matrix the product of a matrix by a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Scalar to premultiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Matrix by which <code>a</code> is multiplied. The result is added to current instance </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classOFELI_1_1Matrix.html#af6d9078abcad160961668918ffd89df8">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a85abe8e904adb7fd09103d7b3e8e362d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fact</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve linear system. </p>
<p>The matrix is factorized using the LDLt (Crout) decomposition. If this one is already factorized, no further factorization is performed. If the matrix has been modified the user has to refactorize it using the function setLDLt. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance that contains right-hand side on input and solution on output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fact</td><td>Set true if matrix is to be factorized (Default value), false if not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<code>0</code> if solution was normally performed, </li>
<li>
<code>n</code> if the <code>n</code>-th pivot is null. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="classOFELI_1_1Matrix.html#a31a4417e8d251ece6decd21307049dbf">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a27c662f32ce66be2efa47871358fcf10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fact</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve linear system. </p>
<p>The matrix is factorized using the LDLt (Crout) decomposition. If this one is already factorized, no further factorization is performed. If the matrix has been modified the user has to refactorize it using the function setLDLt. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance that contains right-hand side. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance that contains solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fact</td><td>Set true if matrix is to be factorized (Default value), false if not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<code>0</code> if solution was normally performed, </li>
<li>
<code>n</code> if the <code>n</code>-th pivot is null. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="classOFELI_1_1Matrix.html#a4fe82250a093bea1e2d5514748574d80">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7b0e029102ad38f4b814c6523aedb53d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set matrix to 0 and reset factorization parameter. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function must be used if after a factorization, the matrix has modified </dd></dl>

<p>Reimplemented in <a class="el" href="classOFELI_1_1DMatrix.html#ad20897c5c8bd47f5d4005989bead0e55">DMatrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a196d9e08fa42335a41f8e67082215065"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setDiagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize matrix storage in the case where only diagonal terms are stored. </p>
<p>This member function is to be used for explicit time integration schemes </p>

</div>
</div>
<a class="anchor" id="a06fae0c47b38f34c0c764b2b6109f9d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_ getDiag </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>k</code>-th diagonal entry of matrix. </p>
<p>First entry is given by <b>getDiag(1)</b>. </p>

</div>
</div>
<a class="anchor" id="aae8f063011ae37198a6c96ad00da6188"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assembly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Element.html">Element</a> &amp;&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_ *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assembly of element matrix into global matrix. </p>
<p>Case where element matrix is given by a C-array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">el</td><td>Pointer to element instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td><a class="el" href="classOFELI_1_1Element.html" title="To store and treat finite element geometric information. ">Element</a> matrix as a C-array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a377c96d9edc5455d8b81d7f2e75a7437"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Assembly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Side.html">Side</a> &amp;&#160;</td>
          <td class="paramname"><em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_ *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assembly of side matrix into global matrix. </p>
<p>Case where side matrix is given by a C-array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sd</td><td>Pointer to side instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td><a class="el" href="classOFELI_1_1Side.html" title="To store and treat finite element sides (edges in 2-D or faces in 3-D) ">Side</a> matrix as a C-array instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1775cd968f5d809fed17f111c852a8f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prescribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose by a penalty method an essential boundary condition, using the <a class="el" href="classOFELI_1_1Mesh.html" title="To store and manipulate finite element meshes. ">Mesh</a> instance provided by the constructor. </p>
<p>This member function modifies diagonal terms in matrix and terms in vector that correspond to degrees of freedom with nonzero code in order to impose a boundary condition. The penalty parameter is defined by default equal to 1.e20. It can be modified by member function <b>setPenal</b>(..). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance that contains right-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance that contains imposed valued at DOFs where they are to be imposed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>Parameter to determine whether only the right-hand side is to be modified (<code>dof&gt;0</code>)<br />
or both matrix and right-hand side (<code>dof=0</code>, default value). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e9143a391d39e2b1c8fc092d18a2c01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prescribe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose by a penalty method an essential boundary condition to a given degree of freedom for a given code. </p>
<p>This member function modifies diagonal terms in matrix and terms in vector that correspond to degrees of freedom with nonzero code in order to impose a boundary condition. The penalty parameter is defined by default equal to 1.e20. It can be modified by member function <b>setPenal</b>(..). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>Degree of freedom for which a boundary condition is to be enforced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>Code for which a boundary condition is to be enforced </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance that contains right-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance that contains imposed valued at DOFs where they are to be imposed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>Parameter to determine whether only the right-hand side is to be modified<br />
(<code>dof&gt;0</code>) or both matrix and right-hand side (<code>dof=0</code>, default value). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d58b8c69697615bb891ad8d89192e11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prescribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose by a penalty method a homegeneous (=0) essential boundary condition. </p>
<p>This member function modifies diagonal terms in matrix and terms in vector that correspond to degrees of freedom with nonzero code in order to impose a boundary condition. The penalty parameter is defined by default equal to 1.e20. It can be modified by member function <b>setPenal</b>(..). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance that contains right-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>Parameter to determine whether only the right-hand side is to be modified (<code>dof&gt;0</code>)<br />
or both matrix and right-hand side (<code>dof=0</code>, default value). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a278a1ed1bb0a7a6df613e63816c8cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prescribe </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose by a penalty method an essential boundary condition when only one DOF is treated. </p>
<p>This member function modifies diagonal terms in matrix and terms in vector that correspond to degrees of freedom with nonzero code in order to impose a boundary condition. This gunction is to be used if only one DOF per node is treated in the linear system. The penalty parameter is by default equal to 1.e20. It can be modified by member function setPenal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>Label of the concerned degree of freedom (DOF). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance that contains right-hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance that conatins imposed valued at DOFs where they are to be imposed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>Parameter to determine whether only the right-hand side is to be modified (<code>dof&gt;0</code>)<br />
or both matrix and right-hand side (<code>dof=0</code>, default value). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4668862b3d13a8ac8ffec768b7e38631"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PrescribeSide </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose by a penalty method an essential boundary condition when DOFs are supported by sides. </p>
<p>This member function modifies diagonal terms in matrix and terms in vector that correspond to degrees of freedom with nonzero code in order to impose a boundary condition. The penalty parameter is defined by default equal to 1.e20. It can be modified by member function <b>setPenal</b>(..). </p>

</div>
</div>
<a class="anchor" id="af70ebb919bf4d6e5e646c1c113392a79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FactorAndSolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factorize matrix and solve the linear system. </p>
<p>This is available only if the storage cass enables it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance that contains right-hand side on input and solution on output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad20265f18b86fdc36c0c694d34bb01db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FactorAndSolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOFELI_1_1Vect.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factorize matrix and solve the linear system. </p>
<p>This is available only if the storage class enables it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance that contains right-hand side </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td><a class="el" href="classOFELI_1_1Vect.html" title="To handle general purpose vectors. ">Vect</a> instance that contains solution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<code>0</code> if solution was normally performed </li>
<li>
<code>n</code> if the n-th pivot is nul </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1db6c5f267140ce71d02b845638d6229"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int isFactorized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Say if matrix is factorized or not. </p>
<p>If the matrix was not factorized, the class does not allow solving by a direct solver. </p>

</div>
</div>
<a class="anchor" id="a5ddc9619401846e377b99d5f35e21580"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_ operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator () with one argument (Constant version). </p>
<p>Returns <code>i</code>-th position in the array storing matrix entries. The first entry is at location 1. Entries are stored row by row. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>entry index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7fb7738730bfcc21b07ede2b6137fc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_&amp; operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator () with one argument (Non Constant version). </p>
<p>Returns <code>i</code>-th position in the array storing matrix entries. The first entry is at location 1. Entries are stored row by row. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>entry index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a760177d294663b1dd8941afd331b0fbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator [] (Non constant version). </p>
<p>Returns <code>k</code>-th stored element in matrix Index <code>k</code> starts at <code>0</code>. </p>

</div>
</div>
<a class="anchor" id="a0c9fc831c3cfa8fe5b57e99da5ac1e52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_ operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator [] (Constant version). </p>
<p>Returns <code>k</code>-th stored element in matrix Index <code>k</code> starts at <code>0</code>. </p>

</div>
</div>
<a class="anchor" id="aa3cbfbe86d6789ebc8b34b261402fb9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFELI_1_1Matrix.html">Matrix</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Matrix.html">Matrix</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator +=. </p>
<p>Add matrix <code>m</code> to current matrix instance. </p>

</div>
</div>
<a class="anchor" id="a82f89bc074972e8d49e6459ea384d672"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFELI_1_1Matrix.html">Matrix</a>&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOFELI_1_1Matrix.html">Matrix</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator -=. </p>
<p>Subtract matrix <code>m</code> from current matrix instance. </p>

</div>
</div>
<a class="anchor" id="a7c1370eca69f9880d5456fb9f4e1da44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOFELI_1_1Matrix.html">Matrix</a>&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const T_ &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator *=. </p>
<p>Premultiply matrix entries by constant value <code>x</code> </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

</div> <!-- class text -->
</div> <!-- main menu -->
<!-- Google Search -->
<br><br>
<center>
  <div id="cse" style="width: 80%;">Loading</div>
  <script src="http://www.google.com/jsapi" type="text/javascript"></script>
  <script type="text/javascript"> 
     google.load('search', '1', {language : 'en', style : google.loader.themes.SHINY});
     google.setOnLoadCallback(function() {
        var customSearchOptions = {};  var customSearchControl = new google.search.CustomSearchControl(
        '012396140824982761142:-qrywxcfi_o', customSearchOptions);
        customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
        customSearchControl.draw('cse');
     }, true);
   </script>
   <style type="text/css">
     .gsc-control-cse {
     font-family: Verdana, sans-serif;
     border-color: #DAE0E5;
     background-color: #DAE0E5;
   }
   .gsc-control-cse .gsc-table-result { font-family: Verdana, sans-serif; }
   input.gsc-input { border-color: #B6BEC5; }
   input.gsc-search-button {
     border-color: #B6BEC5;
     background-color: #D0D1D4;
   }
   .gsc-tabHeader.gsc-tabhInactive {
     border-color: #999999;
     background-color: #EEEEEE;
   }
   .gsc-tabHeader.gsc-tabhActive {
     border-color: #999999;
     background-color: #999999;
   }
   .gsc-tabsArea { border-color: #999999; }
   .gsc-webResult.gsc-result,
   .gsc-results .gsc-imageResult {
     border-color: #FFFFFF;
     background-color: #FFFFFF;
   }
   .gsc-webResult.gsc-result:hover,
   .gsc-imageResult:hover {
     border-color: #D2D6DC;
     background-color: #EDEDED;
   }
   .gsc-webResult.gsc-result.gsc-promotion:hover {
     border-color: #D2D6DC;
     background-color: #EDEDED;
   }
   .gs-webResult.gs-result a.gs-title:link,
   .gs-webResult.gs-result a.gs-title:link b,
   .gs-imageResult a.gs-title:link,
   .gs-imageResult a.gs-title:link b { color: #0568CD; }
   .gs-webResult.gs-result a.gs-title:visited,
   .gs-webResult.gs-result a.gs-title:visited b,
   .gs-imageResult a.gs-title:visited,
   .gs-imageResult a.gs-title:visited b { color: #0568CD; }
   .gs-webResult.gs-result a.gs-title:hover,
   .gs-webResult.gs-result a.gs-title:hover b,
   .gs-imageResult a.gs-title:hover,
   .gs-imageResult a.gs-title:hover b { color: #0568CD; }
   .gs-webResult.gs-result a.gs-title:active,
   .gs-webResult.gs-result a.gs-title:active b,
   .gs-imageResult a.gs-title:active,
   .gs-imageResult a.gs-title:active b { color: #0568CD; }
   .gsc-cursor-page { color: #0568CD; }
   a.gsc-trailing-more-results:link { color: #0568CD; }
   .gs-webResult .gs-snippet,
   .gs-imageResult .gs-snippet,
   .gs-fileFormatType { color: #5F6A73; }
   .gs-webResult div.gs-visibleUrl,
   .gs-imageResult div.gs-visibleUrl { color: #5F6A73; }
   .gs-webResult div.gs-visibleUrl-short { color: #5F6A73; }
   .gs-webResult div.gs-visibleUrl-short { display: none; }
   .gs-webResult div.gs-visibleUrl-long { display: block; }
   .gs-promotion div.gs-visibleUrl-short { display: none; }
   .gs-promotion div.gs-visibleUrl-long { display: block; }
   .gsc-cursor-box { border-color: #FFFFFF; }
   .gsc-results .gsc-cursor-box .gsc-cursor-page {
      border-color: #999999;
      background-color: #FFFFFF;
      color: #0568CD;
   }
   .gsc-results .gsc-cursor-box .gsc-cursor-current-page {
      border-color: #999999;
      background-color: #999999;
      color: #0568CD;
   }
   .gsc-webResult.gsc-result.gsc-promotion {
      border-color: #D2D6DC;
      background-color: #D0D1D4;
   }
   .gsc-completion-title { color: #0568CD; }
   .gsc-completion-snippet { color: #5F6A73; }
   .gs-promotion a.gs-title:link,
   .gs-promotion a.gs-title:link *,
   .gs-promotion .gs-snippet a:link { color: #0066CC; }
   .gs-promotion a.gs-title:visited,
   .gs-promotion a.gs-title:visited *,
   .gs-promotion .gs-snippet a:visited { color: #0066CC; }
   .gs-promotion a.gs-title:hover,
   .gs-promotion a.gs-title:hover *,
   .gs-promotion .gs-snippet a:hover { color: #0066CC; }
   .gs-promotion a.gs-title:active,
   .gs-promotion a.gs-title:active *,
   .gs-promotion .gs-snippet a:active { color: #0066CC; }
   .gs-promotion .gs-snippet,
   .gs-promotion .gs-title .gs-promotion-title-right,
   .gs-promotion .gs-title .gs-promotion-title-right *  { color: #333333; }
   .gs-promotion .gs-visibleUrl,
   .gs-promotion .gs-visibleUrl-short { color: #5F6A73; }
   </style>
</center>
<!-- End of Google Search Box -->
<br><br><br></p>
<div id="foot_bar">
  Copyright &copy; 1998-2019 Rachid Touzani&nbsp;
</div>
</div> <!-- main -->
</body>
</HTML>
